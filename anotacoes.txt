##################################################################################################################

@EnableSpringDataWebSupport

Anotação para conseguirmos repassar dados da requisição para o Spring Data JPA.
Ex: Pegar o Pageable no parâmetro de um controlador, preenchido com os dados da requisição, 
e repassar para o JpaRepository como critério de consulta.

##################################################################################################################

Por padrão, o Spring ordena a paginação pela chave primária.
Podemos definir mais de um atributo para ser critério de ordenação, com direções diferentes.
	
http://localhost:8080/topicos?page=0&size=2&sort=titulo,asc&sort=dataCriacao,desc

##################################################################################################################

Page<Topico> findByCurso_NomeContainingIgnoreCase(String nome, Pageable pageable);

Caso utilizassemos findByCursoNomeContainingIgnoreCase, e houvesse um
atributo chamado cursoNome na entidade Topico, iria haver erro de
ambiguidade.
Utilizando o underline conseguimos definir que a propriedade após o underline
pertence a entidade que está antes do underline.

##################################################################################################################

O Cache do Spring é inteligente e percebe alterações de valores nos parâmetros da requisição.
Para habilitarmos, precisamos utilizar a anotação @EnableCaching após inserir a dependência.
Basta anotarmos o método que queremos realizar cache com @Cacheable(value = <id do método>), com import do pacote do Spring.

@CacheEvict(value = <id's dos métodos a terem os caches invalidados>, allEntries = true)
Devemos utilizar esta anotação nos métodos que irão precisar invalidar um cache para atualizar as informações cacheadas.

##################################################################################################################

